/**
 * Ê∏∏ÊàèÂ∫ìÈ°µÈù¢
 */

import React, { useEffect, useState } from 'react';
import {
  Row,
  Col,
  Card,
  Input,
  Select,
  Button,
  Space,
  Pagination,
  Empty,
  Spin,
  message,
  Modal,
  Form,
  InputNumber,
  Typography,
  Tag,
  Tooltip,
  Dropdown
} from 'antd';
import {
  SearchOutlined,
  PlusOutlined,
  EditOutlined,
  DeleteOutlined,
  HeartOutlined,
  HeartFilled,
  ImportOutlined,
  FilterOutlined,
  DownOutlined,
  DatabaseOutlined,
  RocketOutlined
} from '@ant-design/icons';
import { useGameStore } from '../../store/games';
import { useAuthStore } from '../../store/auth';
import type { Game, GameForm as GameFormType } from '../../types/game';
import { checkAndInitData } from '../../utils/initData';
import { BatchImportModal } from '../../components/ui/BatchImportModal';
import PageHeader from '../../components/common/PageHeader';
import './Games.css';

const { Search } = Input;
const { Option } = Select;
const { Title, Text } = Typography;
const { Meta } = Card;

/**
 * Ê∏∏ÊàèÂç°ÁâáÁªÑ‰ª∂
 */
const GameCard: React.FC<{
  game: Game;
  isFavorite: boolean;
  onEdit: (game: Game) => void;
  onDelete: (game: Game) => void;
  onToggleFavorite: (gameId: string) => void;
  onLike: (gameId: string) => void;
  canEdit: boolean;
}> = ({ game, isFavorite, onEdit, onDelete, onToggleFavorite, onLike, canEdit }) => {
  return (
    <Card
      className="game-card"
      actions={[
        <Tooltip title={isFavorite ? 'ÂèñÊ∂àÊî∂Ëóè' : 'Ê∑ªÂä†Êî∂Ëóè'} key="favorite">
          <Button
            type="text"
            icon={isFavorite ? <HeartFilled style={{ color: '#ff4d4f' }} /> : <HeartOutlined />}
            onClick={() => onToggleFavorite(game.objectId)}
          />
        </Tooltip>,
        <Tooltip title="ÁÇπËµû" key="like">
          <Button
            type="text"
            onClick={() => onLike(game.objectId)}
          >
            üëç {game.likeCount}
          </Button>
        </Tooltip>,
        ...(canEdit ? [
          <Tooltip title="ÁºñËæë" key="edit">
            <Button
              type="text"
              icon={<EditOutlined />}
              onClick={() => onEdit(game)}
            />
          </Tooltip>,
          <Tooltip title="Âà†Èô§" key="delete">
            <Button
              type="text"
              danger
              icon={<DeleteOutlined />}
              onClick={() => onDelete(game)}
            />
          </Tooltip>
        ] : [])
      ]}
    >
      <Meta
        title={
          <div className="game-title">
            <span>{game.name}</span>
            {game.platform && <Tag color="blue">{game.platform}</Tag>}
          </div>
        }
        description={
          <div className="game-description">
            <div className="game-players">
              <Text type="secondary">
                {game.minPlayers === game.maxPlayers 
                  ? `${game.minPlayers} ‰∫∫` 
                  : `${game.minPlayers}-${game.maxPlayers} ‰∫∫`}
              </Text>
            </div>
            {game.type && (
              <div className="game-type">
                <Tag color="green">{game.type}</Tag>
              </div>
            )}
            {game.description && (
              <div className="game-desc">
                <Text ellipsis={{ tooltip: game.description }}>
                  {game.description}
                </Text>
              </div>
            )}
          </div>
        }
      />
    </Card>
  );
};

/**
 * Ê∏∏ÊàèË°®ÂçïÁªÑ‰ª∂
 */
const GameForm: React.FC<{
  visible: boolean;
  game?: Game;
  onSubmit: (values: GameFormType) => void;
  onCancel: () => void;
  loading: boolean;
}> = ({ visible, game, onSubmit, onCancel, loading }) => {
  const [form] = Form.useForm();

  useEffect(() => {
    if (visible && game) {
      form.setFieldsValue({
        name: game.name,
        minPlayers: game.minPlayers,
        maxPlayers: game.maxPlayers,
        platform: game.platform,
        type: game.type,
        description: game.description
      });
    } else if (visible) {
      form.resetFields();
    }
  }, [visible, game, form]);

  const handleSubmit = async () => {
    try {
      const values = await form.validateFields();
      onSubmit(values);
    } catch (error) {
      console.error('Ë°®ÂçïÈ™åËØÅÂ§±Ë¥•:', error);
    }
  };

  return (
    <Modal
      title={game ? 'ÁºñËæëÊ∏∏Êàè' : 'Ê∑ªÂä†Ê∏∏Êàè'}
      open={visible}
      onOk={handleSubmit}
      onCancel={onCancel}
      confirmLoading={loading}
      width={600}
    >
      <Form
        form={form}
        layout="vertical"
        initialValues={{
          minPlayers: 1,
          maxPlayers: 4
        }}
      >
        <Form.Item
          name="name"
          label="Ê∏∏ÊàèÂêçÁß∞"
          rules={[
            { required: true, message: 'ËØ∑ËæìÂÖ•Ê∏∏ÊàèÂêçÁß∞' },
            { max: 100, message: 'Ê∏∏ÊàèÂêçÁß∞‰∏çËÉΩË∂ÖËøá100‰∏™Â≠óÁ¨¶' }
          ]}
        >
          <Input placeholder="ËØ∑ËæìÂÖ•Ê∏∏ÊàèÂêçÁß∞" />
        </Form.Item>

        <Row gutter={16}>
          <Col span={12}>
            <Form.Item
              name="minPlayers"
              label="ÊúÄÂ∞ë‰∫∫Êï∞"
              rules={[
                { required: true, message: 'ËØ∑ËæìÂÖ•ÊúÄÂ∞ë‰∫∫Êï∞' },
                { type: 'number', min: 1, message: 'ÊúÄÂ∞ë‰∫∫Êï∞‰∏çËÉΩÂ∞è‰∫é1' }
              ]}
            >
              <InputNumber min={1} max={100} style={{ width: '100%' }} />
            </Form.Item>
          </Col>
          <Col span={12}>
            <Form.Item
              name="maxPlayers"
              label="ÊúÄÂ§ö‰∫∫Êï∞"
              rules={[
                { required: true, message: 'ËØ∑ËæìÂÖ•ÊúÄÂ§ö‰∫∫Êï∞' },
                { type: 'number', min: 1, message: 'ÊúÄÂ§ö‰∫∫Êï∞‰∏çËÉΩÂ∞è‰∫é1' }
              ]}
            >
              <InputNumber min={1} max={100} style={{ width: '100%' }} />
            </Form.Item>
          </Col>
        </Row>

        <Form.Item
          name="platform"
          label="Ê∏∏ÊàèÂπ≥Âè∞"
        >
          <Input placeholder="Â¶ÇÔºöPC„ÄÅPS5„ÄÅSwitch Á≠â" />
        </Form.Item>

        <Form.Item
          name="type"
          label="Ê∏∏ÊàèÁ±ªÂûã"
        >
          <Input placeholder="Â¶ÇÔºöÁ≠ñÁï•„ÄÅÂ∞ÑÂáª„ÄÅËßíËâ≤ÊâÆÊºî Á≠â" />
        </Form.Item>

        <Form.Item
          name="description"
          label="Ê∏∏ÊàèÊèèËø∞"
        >
          <Input.TextArea
            rows={3}
            placeholder="ËØ∑ÊèèËø∞Ê∏∏ÊàèÁöÑÁâπËâ≤„ÄÅÁé©Ê≥ïÁ≠â..."
            maxLength={500}
            showCount
          />
        </Form.Item>
      </Form>
    </Modal>
  );
};

/**
 * Ê∏∏ÊàèÂ∫ì‰∏ªÈ°µÈù¢
 */
export const Games: React.FC = () => {
  const { user } = useAuthStore();
  const {
    games,
    total,
    loading,
    error,
    currentPage,
    pageSize,
    filters,
    favoriteGames,
    platforms,
    types,
    fetchGames,
    createGame,
    updateGame,
    deleteGame,
    likeGame,
    toggleFavorite,
    setFilters,
    setPage,
    setPageSize,
    clearFilters,
    fetchPlatforms,
    fetchTypes,
    fetchFavoriteGames,
    clearError,
    batchImportGames
  } = useGameStore();

  const [gameFormVisible, setGameFormVisible] = useState(false);
  const [editingGame, setEditingGame] = useState<Game | undefined>();
  const [searchValue, setSearchValue] = useState('');
  const [initLoading, setInitLoading] = useState(false);
  const [batchImportVisible, setBatchImportVisible] = useState(false);

  // ÂàùÂßãÂåñÊï∞ÊçÆ
  useEffect(() => {
    fetchGames();
    fetchFavoriteGames();
    fetchPlatforms();
    fetchTypes();
  }, [fetchGames, fetchFavoriteGames, fetchPlatforms, fetchTypes]);

  // ÈîôËØØÊèêÁ§∫ - Âè™ÊòæÁ§∫Èùû404ÈîôËØØ
  useEffect(() => {
    if (error && !error.includes('Class or object doesn\'t exists')) {
      message.error(error);
      clearError();
    }
  }, [error, clearError]);

  /**
   * Â§ÑÁêÜÊêúÁ¥¢
   */
  const handleSearch = (value: string) => {
    setSearchValue(value);
    setFilters({ ...filters, search: value });
  };

  /**
   * Â§ÑÁêÜÁ≠õÈÄâ
   */
  const handleFilterChange = (key: string, value: string) => {
    setFilters({ ...filters, [key]: value });
  };

  /**
   * Â§ÑÁêÜÊéíÂ∫è
   */
  const handleSortChange = (value: string) => {
    const [sortBy, sortOrder] = value.split(':');
    setFilters({ ...filters, sortBy: sortBy as any, sortOrder: sortOrder as any });
  };

  /**
   * Ê∏ÖÈô§Á≠õÈÄâ
   */
  const handleClearFilters = () => {
    setSearchValue('');
    clearFilters();
  };

  /**
   * Ê∑ªÂä†Ê∏∏Êàè
   */
  const handleAddGame = () => {
    setEditingGame(undefined);
    setGameFormVisible(true);
  };

  /**
   * ÁºñËæëÊ∏∏Êàè
   */
  const handleEditGame = (game: Game) => {
    setEditingGame(game);
    setGameFormVisible(true);
  };

  /**
   * Âà†Èô§Ê∏∏Êàè
   */
  const handleDeleteGame = (game: Game) => {
    Modal.confirm({
      title: 'Á°ÆËÆ§Âà†Èô§',
      content: `Á°ÆÂÆöË¶ÅÂà†Èô§Ê∏∏Êàè„Äå${game.name}„ÄçÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ`,
      onOk: async () => {
        try {
          await deleteGame(game.objectId);
          message.success('Âà†Èô§ÊàêÂäü');
        } catch (error: any) {
          message.error(error.message);
        }
      }
    });
  };

  /**
   * Êèê‰∫§Ê∏∏ÊàèË°®Âçï
   */
  const handleGameFormSubmit = async (values: GameFormType) => {
    try {
      if (editingGame) {
        await updateGame(editingGame.objectId, values);
        message.success('Êõ¥Êñ∞ÊàêÂäü');
      } else {
        await createGame(values);
        message.success('Ê∑ªÂä†ÊàêÂäü');
      }
      setGameFormVisible(false);
    } catch (error: any) {
      message.error(error.message);
    }
  };

  /**
   * ÁÇπËµûÊ∏∏Êàè
   */
  const handleLikeGame = async (gameId: string) => {
    try {
      await likeGame(gameId);
    } catch (error: any) {
      message.error(error.message);
    }
  };

  /**
   * ÂàáÊç¢Êî∂Ëóè
   */
  const handleToggleFavorite = async (gameId: string) => {
    try {
      await toggleFavorite(gameId);
      const isFavorite = favoriteGames.some(game => game.objectId === gameId);
      message.success(isFavorite ? 'Â∑≤ÂèñÊ∂àÊî∂Ëóè' : 'Â∑≤Ê∑ªÂä†Êî∂Ëóè');
    } catch (error: any) {
      message.error(error.message);
    }
  };

  /**
   * Âà§Êñ≠Áî®Êà∑ÊòØÂê¶ÂèØ‰ª•ÁºñËæëÊ∏∏Êàè
   */
  const canEditGame = (game: Game): boolean => {
    return user?.objectId === game.createdBy;
  };

  /**
   * Âà§Êñ≠Ê∏∏ÊàèÊòØÂê¶Ë¢´Êî∂Ëóè
   */
  const isGameFavorite = (gameId: string): boolean => {
    return favoriteGames.some(game => game.objectId === gameId);
  };

  /**
   * ÂàùÂßãÂåñÁ§∫‰æãÊï∞ÊçÆ
   */
  const handleInitSampleData = async () => {
    setInitLoading(true);
    try {
      // ÂÖàÂø´ÈÄüÂª∫Á´ãÊï∞ÊçÆË°®
      const { quickInitTable } = await import('../../utils/initData');
      await quickInitTable();
      
      // ÁÑ∂ÂêéÂàõÂª∫Á§∫‰æãÊï∞ÊçÆ
      const { checkAndInitData } = await import('../../utils/initData');
      await checkAndInitData();
      
      message.success('Á§∫‰æãÊï∞ÊçÆÂàùÂßãÂåñÊàêÂäüÔºÅ');
      
      // ÈáçÊñ∞Ëé∑ÂèñÊï∞ÊçÆ
      await fetchGames();
      await fetchFavoriteGames();
      await fetchPlatforms();
      await fetchTypes();
    } catch (error: any) {
      message.error(`ÂàùÂßãÂåñÂ§±Ë¥•: ${error.message}`);
    } finally {
      setInitLoading(false);
    }
  };

  /**
   * Â§ÑÁêÜÊâπÈáèÂØºÂÖ•
   */
  const handleBatchImport = async (games: GameFormType[]) => {
    return await batchImportGames(games);
  };

  return (
    <div className="games-page">
      <PageHeader
        title="Ê∏∏ÊàèÂ∫ì"
        subtitle="ÂèëÁé∞ÂíåÁÆ°ÁêÜ‰Ω†ÂñúÊ¨¢ÁöÑÊ∏∏Êàè"
        icon={<RocketOutlined />}
      />

      {/* ÊêúÁ¥¢ÂíåÁ≠õÈÄâ */}
      <Card className="games-filters">
        <Row gutter={[16, 16]}>
          <Col xs={24} sm={12} md={8}>
            <Search
              placeholder="ÊêúÁ¥¢Ê∏∏ÊàèÂêçÁß∞..."
              value={searchValue}
              onChange={(e) => setSearchValue(e.target.value)}
              onSearch={handleSearch}
              enterButton={<SearchOutlined />}
              allowClear
            />
          </Col>
          <Col xs={12} sm={6} md={4}>
            <Select
              placeholder="Ê∏∏ÊàèÂπ≥Âè∞"
              style={{ width: '100%' }}
              value={filters.platform}
              onChange={(value) => handleFilterChange('platform', value)}
              allowClear
            >
              {platforms.map(platform => (
                <Option key={platform} value={platform}>{platform}</Option>
              ))}
            </Select>
          </Col>
          <Col xs={12} sm={6} md={4}>
            <Select
              placeholder="Ê∏∏ÊàèÁ±ªÂûã"
              style={{ width: '100%' }}
              value={filters.type}
              onChange={(value) => handleFilterChange('type', value)}
              allowClear
            >
              {types.map(type => (
                <Option key={type} value={type}>{type}</Option>
              ))}
            </Select>
          </Col>
          <Col xs={12} sm={6} md={4}>
            <Select
              placeholder="ÊéíÂ∫èÊñπÂºè"
              style={{ width: '100%' }}
              value={filters.sortBy ? `${filters.sortBy}:${filters.sortOrder || 'desc'}` : undefined}
              onChange={handleSortChange}
              allowClear
            >
              <Option value="createdAt:desc">ÊúÄÊñ∞Ê∑ªÂä†</Option>
              <Option value="createdAt:asc">ÊúÄÊó©Ê∑ªÂä†</Option>
              <Option value="name:asc">ÂêçÁß∞ A-Z</Option>
              <Option value="name:desc">ÂêçÁß∞ Z-A</Option>
              <Option value="likeCount:desc">ÊúÄÂ§öÁÇπËµû</Option>
              <Option value="likeCount:asc">ÊúÄÂ∞ëÁÇπËµû</Option>
            </Select>
          </Col>
          <Col xs={12} sm={6} md={4}>
            <Space>
              <Button
                icon={<FilterOutlined />}
                onClick={handleClearFilters}
              >
                Ê∏ÖÈô§Á≠õÈÄâ
              </Button>
              <Dropdown
                menu={{
                  items: [
                    {
                      key: 'single',
                      label: 'Âçï‰∏™Ê∑ªÂä†',
                      icon: <PlusOutlined />,
                      onClick: handleAddGame
                    },
                    {
                      key: 'batch',
                      label: 'ÊâπÈáèÂØºÂÖ•',
                      icon: <DatabaseOutlined />,
                      onClick: () => setBatchImportVisible(true)
                    }
                  ]
                }}
                trigger={['click']}
              >
                <Button type="primary">
                  Ê∑ªÂä†Ê∏∏Êàè <DownOutlined />
                </Button>
              </Dropdown>
            </Space>
          </Col>
        </Row>
      </Card>

      {/* Ê∏∏ÊàèÂàóË°® */}
      <Spin spinning={loading || initLoading}>
        {games.length > 0 ? (
          <>
            <Row gutter={[16, 16]}>
              {games.map(game => (
                <Col key={game.objectId} xs={24} sm={12} md={8} lg={6}>
                  <GameCard
                    game={game}
                    isFavorite={isGameFavorite(game.objectId)}
                    onEdit={handleEditGame}
                    onDelete={handleDeleteGame}
                    onToggleFavorite={handleToggleFavorite}
                    onLike={handleLikeGame}
                    canEdit={canEditGame(game)}
                  />
                </Col>
              ))}
            </Row>

            {/* ÂàÜÈ°µ */}
            <div className="games-pagination">
              <Pagination
                current={currentPage}
                total={total}
                pageSize={pageSize}
                onChange={setPage}
                onShowSizeChange={(current, size) => setPageSize(size)}
                showSizeChanger
                showQuickJumper
                showTotal={(total, range) => 
                  `Á¨¨ ${range[0]}-${range[1]} Êù°ÔºåÂÖ± ${total} Êù°`
                }
              />
            </div>
          </>
        ) : (
          <Empty
            description={
              <div>
                <p>ËøòÊ≤°ÊúâÊ∏∏ÊàèÊï∞ÊçÆ</p>
                <Text type="secondary">
                  ‰Ω†ÂèØ‰ª•ÊâãÂä®Ê∑ªÂä†Ê∏∏ÊàèÔºåÊàñËÄÖÂä†ËΩΩ‰∏Ä‰∫õÁ≤æÈÄâÁöÑÁ§∫‰æãÊ∏∏ÊàèÊù•Âø´ÈÄüÂºÄÂßã‰ΩìÈ™å
                </Text>
                <br />
                <div style={{ 
                  background: '#f6ffed', 
                  border: '1px solid #b7eb8f', 
                  borderRadius: '6px', 
                  padding: '8px 12px', 
                  margin: '8px 0',
                  fontSize: '12px' 
                }}>
                  üí° <strong>È¶ñÊ¨°‰ΩøÁî®ÊèêÁ§∫</strong>ÔºöÊéßÂà∂Âè∞ÁöÑ404ÈîôËØØÊòØÊ≠£Â∏∏ÁöÑÔºåÁÇπÂáª‰∏ãÊñπÊåâÈíÆÂç≥ÂèØËß£ÂÜ≥
                </div>
              </div>
            }
            image={Empty.PRESENTED_IMAGE_SIMPLE}
          >
            <Space>
              <Button 
                type="primary" 
                onClick={handleAddGame}
                icon={<PlusOutlined />}
              >
                ÊâãÂä®Ê∑ªÂä†Ê∏∏Êàè
              </Button>
              <Button 
                onClick={() => setBatchImportVisible(true)}
                icon={<DatabaseOutlined />}
                type="default"
              >
                ÊâπÈáèÂØºÂÖ•Ê∏∏Êàè
              </Button>
              <Button 
                onClick={handleInitSampleData}
                loading={initLoading}
                icon={<ImportOutlined />}
                type="default"
              >
                {initLoading ? 'Ê≠£Âú®Âä†ËΩΩÁ§∫‰æãÊï∞ÊçÆ...' : 'Âä†ËΩΩ7‰∏™Á≤æÈÄâÊ∏∏Êàè'}
              </Button>
            </Space>
          </Empty>
        )}
      </Spin>

      {/* Ê∏∏ÊàèË°®ÂçïÂØπËØùÊ°Ü */}
      <GameForm
        visible={gameFormVisible}
        game={editingGame}
        loading={loading}
        onSubmit={handleGameFormSubmit}
        onCancel={() => setGameFormVisible(false)}
      />

      {/* ÊâπÈáèÂØºÂÖ•ÂØπËØùÊ°Ü */}
      <BatchImportModal
        visible={batchImportVisible}
        loading={loading}
        onImport={handleBatchImport}
        onCancel={() => setBatchImportVisible(false)}
      />
    </div>
  );
}; 